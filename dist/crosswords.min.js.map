{"version":3,"sources":["crossword.js","crossworddom.js"],"names":[],"mappings":"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","file":"crosswords.min.js","sourcesContent":["var CrosswordsJS = (function(CrosswordsJS, window, document) {\n\n  'use strict';\n\n  function buildObjectArray2D(x, y) {\n    var array = new Array(x);\n    for(var i=0; i<y; i++) {\n      array[i] = new Array(y);\n      for(var j=0; j<y; j++) {\n        array[i][j] = {};\n      }\n    }\n    return array;\n  }\n\n  //  The crossword class. When a crossword is built from a definition\n  //  and options, this is the object which is returned.\n  function Crossword(crosswordDefinition) {\n\n    if(!crosswordDefinition) {\n      throw new Error(\"The Crossword must be initialised with a crossword definition.\");\n    }\n  \n    //  Set up some data we'll store in the class.\n    this.width = crosswordDefinition.width;\n    this.height = crosswordDefinition.height;\n    this.acrossClues = [];\n    this.downClues = [];\n    this.cells = buildObjectArray2D(this.width, this.height);\n\n    //  Validate the bounds.\n    if(this.width === undefined || this.width === null || this.width < 0 ||\n      this.height === undefined || this.height === null || this.height < 0) {\n      throw new Error(\"The crossword bounds are invalid.\");\n    }\n\n    //  We're going to go through the across clues, then the down clues.\n    var clueDefinitions = crosswordDefinition.acrossClues.concat(crosswordDefinition.downClues);\n    for(var c = 0; c < clueDefinitions.length; c++) {\n    \n      //  Grab the clue and build a flag letting us know if we're across or down.\n      var clueDefinition = clueDefinitions[c];\n      var across = c < crosswordDefinition.acrossClues.length;\n    \n      //  Create a model for the clue.\n      var clueModel = {\n        number: clueDefinition.number,\n        code: clueDefinition.number + (across ? \"a\" : \"d\"),\n        answer: clueDefinition.answer,\n        x: clueDefinition.x - 1,    //  Definitions are 1 based, models are more useful 0 based.\n        y: clueDefinition.y - 1,\n        across: across,\n        length: [],\n        totalLength: 0,\n        clue: clueDefinition.clue,\n        cells: []\n      };\n      this[across ? 'acrossClues' : 'downClues'].push(clueModel);\n\n      //  The clue position must be in the bounds.\n      if(clueModel.x < 0 || clueModel.x >= this.width || clueModel.y < 0 || clueModel.y >= this.height) {\n        throw new Error(\"Clue \" + clueModel.code + \" doesn't start in the bounds.\");\n      }\n\n      //  Copy over the clue definition length into the model,\n      //  also keeping track of the total length.\n      for(var i = 0; i < clueDefinition.length.length; i++) {\n        clueModel.length.push(clueDefinition.length[i]);\n        clueModel.totalLength += clueDefinition.length[i];\n      }\n\n      //  Make sure the clue is not too long.\n      if(across) {\n        if((clueModel.x + clueModel.totalLength) > this.width) {\n          throw new Error(\"Clue \" + clueModel.code + \" exceeds horizontal bounds.\");\n        }\n      } else {\n        if((clueModel.y + clueModel.totalLength) > this.height) {\n          throw new Error(\"Clue \" + clueModel.code + \" exceeds vertical bounds.\");\n        }\n      }\n\n      //  We can now mark the cells as light. If the clue has \n      //  an answer (which is optional), we can validate it \n      //  is coherent.\n      var x = clueModel.x;\n      var y = clueModel.y;\n      for(var letter = 0; letter < clueModel.totalLength; letter++) {\n        var cell = this.cells[x][y];\n        cell.light = true;\n        cell[across ? 'acrossClue' : 'downClue'] = clueModel;\n        cell[across ? 'acrossClueLetterIndex' : 'downClueLetterIndex'] = letter;\n        clueModel.cells.push(cell);\n\n        //  If the clue has an answer we set it in the cell...\n        if(clueModel.answer) {\n\n          //  ...but only if it is not different to an existing answer.\n          if(cell.answer !== undefined && cell.answer !== clueModel.answer[letter]) {\n            throw new Error(\"Clue \" + clueModel.code + \" answer at (\" + (x + 1) + \", \" + (y + 1) + \") is not coherent with previous clue (\" + cell.acrossClue.code + \") answer.\");\n          }\n          cell.answer = clueModel.answer[letter];\n        }\n\n        if(letter === 0) {\n          if(cell.clueLabel && cell.clueLabel !== clueModel.number) {\n            throw new Error(\"Clue \" + clueModel.code + \" has a label which is inconsistent with another clue (\" + cell.acrossClue.code + \").\");\n          }\n          cell.clueLabel = clueModel.number;\n        }\n\n        if(across) {\n          x++;\n        } else {\n          y++;\n        }\n      }\n    }\n  }\n\n  //  Define our public API.\n  CrosswordsJS.Crossword = Crossword;\n  return CrosswordsJS;\n\n})(CrosswordsJS || {}, window, document);","var CrosswordsJS = (function(CrosswordsJS, window, document) {\n\n  'use strict';\n\n  //  Lightweight helper functions.\n  function removeClass(element, className) {\n    var expression = new RegExp(\"(?:^|\\\\s)\" + className + \"(?!\\\\S)\", \"g\");\n    element.className = element.className.replace(expression, '');\n  }\n  function addClass(element, className) {\n    element.className += \" \" + className;\n  }\n\n  //  Internally used map of Crossword model data to DOM elements.\n  function CellMap() {\n    this.map = [];\n  }\n\n  //  Adds a Cell <-> Cell Element mapping.\n  CellMap.prototype.add = function(cell, cellElement) {\n    this.map.push({\n      cell: cell,\n      cellElement: cellElement\n    });\n  };\n\n  //  Gets the DOM element for a cell.\n  CellMap.prototype.getCellElement = function(cell) {\n    for(var i=0; i<this.map.length; i++) {\n      if(this.map[i].cell === cell) { \n        return this.map[i].cellElement;\n      }\n    }\n    return null;\n  };\n\n  //  Gets the cell for a DOM element.\n  CellMap.prototype.getCell = function(cellElement) {\n    for(var i=0; i<this.map.length; i++) {\n      if(this.map[i].cellElement === cellElement) { \n        return this.map[i].cell;\n      }\n    }\n    return null;\n  };\n\n\n  //  Removes entries for a crossword.\n  CellMap.prototype.removeCrosswordCells = function removeCrosswordCells(crossword) {\n    for(var i=0; i<this.map.length; i++) {\n      if(this.map[i].cell.crossword === crossword) { \n        this.map.splice(i, 1);\n      }\n    }\n  };\n\n  var getCellElementData = function getCellElementData(cellElement) {\n    for(var i = 0; i < cellMap.length; i++) {\n      if(cellMap[i].cellElement === cellElement) {\n        return cellMap[i];\n      }\n    }\n    return null;\n  };\n\n  //  Creates the DOM representation of a Crossword.\n  function CrosswordDOM(crossword, parentElement) {\n\n    this.crossword = crossword;\n    this.parentElement = parentElement;\n\n    //  Now build the DOM for the crossword.\n    var container = document.createElement('div');\n    container.className = \"crossword\";\n\n    //  Create each cell.\n    for(var y = 0; y < crossword.height; y++) {\n\n      var row = document.createElement('div');\n      row.className = \"cwrow\";\n      container.appendChild(row);\n\n      for(var x = 0; x < crossword.width; x++) {\n\n        var cell = crossword.cells[x][y];\n\n        //  Build the cell element and add it to the row.\n        var cellElement = this._createCellDOM(cell);\n        row.appendChild(cellElement);\n\n        //  Update the map of cells\n        cellMap.add(cell, cellElement);\n\n      }\n\n    }\n\n    parentElement.appendChild(container);\n    this.crosswordElement = container;\n  }\n\n  //  Selects a clue.\n  CrosswordDOM.prototype.selectClue = function selectClue(clue) {\n    this.currentClue = clue;\n    this._updateDOM();\n    cellMap.getCellElement(clue.cells[0]).focus();\n    this._stateChange(\"clueSelected\");\n  };\n\n  //  Completely cleans up the crossword.\n  CrosswordDOM.prototype.destroy = function destroy() {\n    \n    //  Clear the map, DOM and state change handler.\n    cellMap.removeCrosswordCells(this.crossword);\n    this.parentElement.removeChild(this.crosswordElement);\n    this.onStateChanged = null;\n\n  };\n\n  //  Sends a state change message.\n  CrosswordDOM.prototype._stateChange = function _stateChange(message, data) {\n\n    var eventHandler = this.onStateChanged;\n    if(!eventHandler) {\n      return;\n    }\n\n    //  Send the message.\n    eventHandler({\n      message: message,\n      data: data\n    });\n\n  };\n\n  //  Creates DOM for a cell.\n  CrosswordDOM.prototype._createCellDOM = function _createCellDOM(cell) {\n\n    var self = this;\n    var cellElement = document.createElement('div');\n    cellElement.className = \"cwcell\";\n    cell.cellElement = cellElement;\n\n    //  Add a class.\n    cellElement.className += cell.light ? \" light\" : \" dark\";\n\n    //  If the cell is dark, we are done.\n    if(!cell.light) {\n      return cellElement;\n    }\n\n    //  Light cells also need an input.\n    var inputElement = document.createElement('input');\n    inputElement.maxLength = 1;\n    cellElement.appendChild(inputElement);\n\n    //  We may need to add a clue label.\n    if(cell.clueLabel) {\n      var clueLabel = document.createElement('div');\n      clueLabel.className = \"cwcluelabel\";\n      clueLabel.innerHTML = cell.clueLabel;\n      cellElement.appendChild(clueLabel);\n    }\n\n    //  Listen for focus events.\n    inputElement.addEventListener(\"focus\", function(event) {\n\n      //  Get the cell data.\n      var cellElement = event.target.parentNode;\n      var cell = cellMap.getCell(cellElement);\n      var crossword = cell.crossword;\n      var across = cell.acrossClue;\n      var down = cell.downClue;\n\n      //  If we have clicked somewhere which is part of the current clue, we\n      //  will not need to change it (we won't toggle either).\n      if(self.currentClue && \n         (self.currentClue === across ||\n          self.currentClue === down)) {\n        return;\n      }\n\n      //  If we have an across clue XOR a down clue, pick the one we have.\n      if( (across && !down) || (!across && down) ) {\n        self.currentClue = across || down;\n      } else {\n        //  We've got across AND down. Prefer across, unless we've on the \n        //  first letter of a down clue only\n        self.currentClue = cell.downClueLetterIndex === 0 && cell.acrossClueLetterIndex !== 0 ? down : across;     \n      }\n\n      //  Update the DOM, inform of state change.\n      self._updateDOM();\n      self._stateChange(\"clueSelected\");\n      \n    });\n\n    //  Listen for keydown events.\n    cellElement.addEventListener(\"keydown\", function(event) {\n\n      if(event.keyCode === 8) { // backspace\n          \n        //  Blat the contents of the cell. No need to process the backspace.\n        event.preventDefault();\n        event.target.value = \"\";\n\n        //  Try and move to the previous cell of the clue.\n        var cellElement = event.target.parentNode;\n        var cell = cellMap.getCell(cellElement);\n        var currentIndex = cell.acrossClue === self.currentClue ? self.acrossClueLetterIndex : self.downClueLetterIndex;\n        var previousIndex = currentIndex - 1;\n        if(previousIndex >= 0) {\n          self.currentClue.cells[previousIndex].cellElement.querySelector('input').focus();\n        }\n\n      } else if(event.keyCode === 9) { // tab\n\n        //  We don't want default behaviour.\n        event.preventDefault();\n\n        //  Get the cell element and cell data.\n        var cellElement = event.target.parentNode;\n        var cell = cellMap.getCell(cellElement);\n        var crossword = cell.crossword;\n        var clue = self.currentClue;\n\n        //  Get the next clue.\n        var searchClues = clue.across ? crossword.acrossClues : crossword.downClues;\n        for(var i=0; i<searchClues.length; i++) {\n          if(clue === searchClues[i]) {\n            var newClue = null;\n            if(event.shiftKey) {\n              if(i > 0) {\n                newClue = searchClues[i-1];\n              } else {\n                newClue = clue.across ? crossword.downClues[crossword.downClues.length-1] : crossword.acrossClues[crossword.acrossClues.length-1];\n              }\n            } else {\n              if(i < (searchClues.length - 1)) {\n                newClue = searchClues[i+1];\n              } else {\n                newClue = clue.across ? crossword.downClues[0] : crossword.acrossClues[0];\n              }\n            }\n            //  Select the new clue.\n            self.currentClue = newClue;\n            self._updateDOM();\n            cellMap.getCellElement(newClue.cells[0]).querySelector('input').focus({internal: true});\n            break;\n          }\n        }\n\n      } else if (event.keyCode === 13) { // enter\n\n        //  We don't want default behaviour.\n        event.preventDefault();\n\n        //  Get the cell element and cell data.\n        var cellElement = event.target.parentNode;\n        var cell = cellMap.getCell(cellElement);\n        var crossword = cell.crossword;\n\n        //  If we are in a cell with an across clue AND down clue, swap the\n        //  selected one.\n        if(cell.acrossClue && cell.downClue) {\n          self.currentClue = cell.acrossClue === self.currentClue ? cell.downClue : cell.acrossClue;\n          self._updateDOM();\n        }\n\n      }\n\n    });\n\n    //  Listen for keypress events.\n    cellElement.addEventListener(\"keypress\", function(event) {\n\n      //  We've just pressed a key that generates a char. In all\n      //  cases, we're going to overwrite by blatting the current \n      //  content. If the key is space, we suppress so we don't get\n      //  a space, then we always move to the next cell in the clue.\n      \n      //  No spaces in empty cells.\n      if(event.keyCode === 32) {\n        event.preventDefault();\n      }\n\n      //  Blat current content.\n      event.target.value = \"\";\n\n      //  Move to the next cell in the clue.\n      var cellElement = event.target.parentNode;\n      var cell = cellMap.getCell(cellElement);\n      var crossword = cell.crossword;\n      var clue = self.currentClue;\n      var currentIndex = cell.acrossClue === clue ? cell.acrossClueLetterIndex : cell.downClueLetterIndex;\n      var nextIndex = currentIndex + 1;\n      if(nextIndex < clue.cells.length) {\n        clue.cells[nextIndex].cellElement.querySelector('input').focus();\n      }\n\n    });\n\n    //  Listen for keyup events.\n    cellElement.addEventListener(\"keyup\", function(event) {\n      switch (event.keyCode) {\n        case 37: // left\n        \n          var cellElement = event.target.parentNode;\n          var cell = cellMap.getCell(cellElement);\n          var x = cell.x, y = cell.y;\n\n          //  If we can go left, go left.\n          if(cell.x > 0 && cellData.crossword.cells[x-1][y].light === true) {\n            //  TODO: optimise with children[0]?\n            cellMap.getCellElement(cell.crossword.cells[x-1][y]).querySelector('input').focus();\n          }\n          break;\n        case 38: // up\n          var cellElement = event.target.parentNode;\n          var cell = cellMap.getCell(cellElement);\n          var x = cell.x, y = cell.y;\n\n          //  If we can go up, go up.\n          if(cell.y > 0 && cellData.crossword.cells[x][y-1].light === true) {\n            //  TODO: optimise with children[0]?\n            cellMap.getCellElement(cell.crossword.cells[x][y-1]).querySelector('input').focus();\n          }\n          break;\n        case 39: // right\n          var cellElement = event.target.parentNode;\n          var cell = cellMap.getCell(cellElement);\n          var width = cell.crossword.width;\n          var x = cell.x, y = cell.y;\n\n          //  If we can go right, go right.\n          if(cell.x + 1 < width && cell.crossword.cells[x+1][y].light === true) {\n            //  TODO: optimise with children[0]?\n            cellMap.getCellElement(cell.crossword.cells[x+1][y]).querySelector('input').focus();\n          }\n          break;\n        case 40: // down\n          var cellElement = event.target.parentNode;\n          var cell = cellMap.getCell(cellElement);\n          var height = cell.crossword.height;\n          var x = cell.x, y = cell.y;\n\n          //  If we can go down, go down.\n          if(cell.y + 1 < height && cell.crossword.cells[x][y+1].light === true) {\n            //  TODO: optimise with children[0]?\n            cellMap.getCellElement(cell.crossword.cells[x][y+1]).querySelector('input').focus();\n          }\n          break;\n        case 9: // tab\n          //  todo\n          break;\n\n        default: // anything else...\n          //  todo\n          break;\n      }\n    });\n\n    return cellElement;\n  };\n\n  //  Updates the DOM based on the model, ensuring that the CSS\n  //  is correct for the state (i.e. the selected clue).\n  CrosswordDOM.prototype._updateDOM = function _updateDOM() {\n\n    //  TODO: pick a name - active, current or selected.\n    var activeClue = this.currentClue;\n    var crossword = this.crossword;\n\n    //  Deactivate all cells, except those which match the clue.\n    for(var x = 0; x < crossword.cells.length; x++) {\n      for(var y = 0; y < crossword.cells[x].length; y++) {\n        var cell = crossword.cells[x][y];\n        if(cell.light === true) { \n          if((cell.acrossClue === activeClue) || (cell.downClue === activeClue)) {\n            addClass(cellMap.getCellElement(cell).querySelector('input'), \"active\");\n          } else {\n            removeClass(cellMap.getCellElement(cell).querySelector('input'), \"active\");\n          }\n        }\n      }\n    }\n  };\n\n  //  Create a single global instance of a cell map.\n  var cellMap = new CellMap();\n\n  //  Define our public API.\n  CrosswordsJS.CrosswordDOM = CrosswordDOM;\n  return CrosswordsJS;\n\n})(CrosswordsJS || {}, window, document);"],"sourceRoot":"/source/"}
{"version":3,"sources":["crossword.js"],"names":["CrosswordsJS","window","document","removeClass","element","className","expression","RegExp","replace","addClass","buildObjectArray2D","x","y","array","Array","i","j","Crossword","crosswordDefinition","Error","this","width","height","acrossClues","downClues","cells","undefined","clueDefinitions","concat","c","length","clueDefinition","across","clueModel","number","code","answer","totalLength","clue","push","letter","cell","light","acrossClue","clueLabel","cellMap","getCellElementData","cellElement","prototype","createDOM","parentElement","container","createElement","row","appendChild","_createCellDOM","crossword","selectClue","currentClue","_updateDOM","focus","_stateChange","destroyDOM","entry","splice","removeChild","crosswordElement","onStateChanged","message","data","eventHandler","inputElement","maxLength","innerHTML","addEventListener","event","target","parentNode","cellData","down","downClue","downClueLetterIndex","acrossClueLetterIndex","keyCode","preventDefault","value","currentIndex","previousIndex","querySelector","model","searchClues","newClue","shiftKey","internal","nextIndex","activeClue","CrosswordDOM"],"mappings":"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","file":"crosswords.min.js","sourcesContent":["var CrosswordsJS = (function(window, document) {\r\n\r\n  'use strict';\r\n\r\n  //  Lightweight helper functions.\r\n  function removeClass(element, className) {\r\n    var expression = new RegExp(\"(?:^|\\\\s)\" + className + \"(?!\\\\S)\", \"g\");\r\n    element.className = element.className.replace(expression, '');\r\n  }\r\n  function addClass(element, className) {\r\n    element.className += \" \" + className;\r\n  }\r\n  function buildObjectArray2D(x, y) {\r\n    var array = new Array(x);\r\n    for(var i=0; i<y; i++) {\r\n      array[i] = new Array(y);\r\n      for(var j=0; j<y; j++) {\r\n        array[i][j] = {};\r\n      }\r\n    }\r\n    return array;\r\n  }\r\n\r\n  //  The cellmap ties cell elements to the crossword that owns them.\r\n  var cellMap = [];\r\n  var getCellElementData = function getCellElementData(cellElement) {\r\n    for(var i = 0; i < cellMap.length; i++) {\r\n      if(cellMap[i].cellElement === cellElement) {\r\n        return cellMap[i];\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n\r\n  //  The crossword class. When a crossword is built from a definition\r\n  //  and options, this is the object which is returned.\r\n  function Crossword(crosswordDefinition) {\r\n\r\n    if(!crosswordDefinition) {\r\n      throw new Error(\"The Crossword must be initialised with a crossword definition.\");\r\n    }\r\n  \r\n    //  Set up some data we'll store in the class.\r\n    this.width = crosswordDefinition.width;\r\n    this.height = crosswordDefinition.height;\r\n    this.acrossClues = [];\r\n    this.downClues = [];\r\n    this.cells = buildObjectArray2D(this.width, this.height);\r\n\r\n    //  Validate the bounds.\r\n    if(this.width === undefined || this.width === null || this.width < 0 ||\r\n      this.height === undefined || this.height === null || this.height < 0) {\r\n      throw new Error(\"The crossword bounds are invalid.\");\r\n    }\r\n\r\n    //  We're going to go through the across clues, then the down clues.\r\n    var clueDefinitions = crosswordDefinition.acrossClues.concat(crosswordDefinition.downClues);\r\n    for(var c = 0; c < clueDefinitions.length; c++) {\r\n    \r\n      //  Grab the clue and build a flag letting us know if we're across or down.\r\n      var clueDefinition = clueDefinitions[c];\r\n      var across = c < crosswordDefinition.acrossClues.length;\r\n    \r\n      //  Create a model for the clue.\r\n      var clueModel = {\r\n        number: clueDefinition.number,\r\n        code: clueDefinition.number + (across ? \"a\" : \"d\"),\r\n        answer: clueDefinition.answer,\r\n        x: clueDefinition.x - 1,    //  Definitions are 1 based, models are more useful 0 based.\r\n        y: clueDefinition.y - 1,\r\n        across: across,\r\n        length: [],\r\n        totalLength: 0,\r\n        clue: clueDefinition.clue,\r\n        cells: []\r\n      };\r\n      this[across ? 'acrossClues' : 'downClues'].push(clueModel);\r\n\r\n      //  The clue position must be in the bounds.\r\n      if(clueModel.x < 0 || clueModel.x >= this.width || clueModel.y < 0 || clueModel.y >= this.height) {\r\n        throw new Error(\"Clue \" + clueModel.code + \" doesn't start in the bounds.\");\r\n      }\r\n\r\n      //  Copy over the clue definition length into the model,\r\n      //  also keeping track of the total length.\r\n      for(var i = 0; i < clueDefinition.length.length; i++) {\r\n        clueModel.length.push(clueDefinition.length[i]);\r\n        clueModel.totalLength += clueDefinition.length[i];\r\n      }\r\n\r\n      //  Make sure the clue is not too long.\r\n      if(across) {\r\n        if((clueModel.x + clueModel.totalLength) > this.width) {\r\n          throw new Error(\"Clue \" + clueModel.code + \" exceeds horizontal bounds.\");\r\n        }\r\n      } else {\r\n        if((clueModel.y + clueModel.totalLength) > this.height) {\r\n          throw new Error(\"Clue \" + clueModel.code + \" exceeds vertical bounds.\");\r\n        }\r\n      }\r\n\r\n      //  We can now mark the cells as light. If the clue has \r\n      //  an answer (which is optional), we can validate it \r\n      //  is coherent.\r\n      var x = clueModel.x;\r\n      var y = clueModel.y;\r\n      for(var letter = 0; letter < clueModel.totalLength; letter++) {\r\n        var cell = this.cells[x][y];\r\n        cell.light = true;\r\n        cell[across ? 'acrossClue' : 'downClue'] = clueModel;\r\n        cell[across ? 'acrossClueLetterIndex' : 'downClueLetterIndex'] = letter;\r\n        clueModel.cells.push(cell);\r\n\r\n        //  If the clue has an answer we set it in the cell...\r\n        if(clueModel.answer) {\r\n\r\n          //  ...but only if it is not different to an existing answer.\r\n          if(cell.answer !== undefined && cell.answer !== clueModel.answer[letter]) {\r\n            throw new Error(\"Clue \" + clueModel.code + \" answer at (\" + (x + 1) + \", \" + (y + 1) + \") is not coherent with previous clue (\" + cell.acrossClue.code + \") answer.\");\r\n          }\r\n          cell.answer = clueModel.answer[letter];\r\n        }\r\n\r\n        if(letter === 0) {\r\n          if(cell.clueLabel && cell.clueLabel !== clueModel.number) {\r\n            throw new Error(\"Clue \" + clueModel.code + \" has a label which is inconsistent with another clue (\" + cell.acrossClue.code + \").\");\r\n          }\r\n          cell.clueLabel = clueModel.number;\r\n        }\r\n\r\n        if(across) {\r\n          x++;\r\n        } else {\r\n          y++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  //  Creates the DOM representation for the crossword.\r\n  Crossword.prototype.createDOM = function createDOM(parentElement) {\r\n\r\n    //  Now build the DOM for the crossword.\r\n    var container = document.createElement('div');\r\n    container.className = \"crossword\";\r\n\r\n    //  Create each cell.\r\n    for(var y = 0; y < this.height; y++) {\r\n\r\n      var row = document.createElement('div');\r\n      row.className = \"cwrow\";\r\n      container.appendChild(row);\r\n\r\n      for(var x = 0; x < this.width; x++) {\r\n\r\n        var cell = this.cells[x][y];\r\n\r\n        //  Build the cell element and add it to the row.\r\n        var cellElement = this._createCellDOM(cell);\r\n        row.appendChild(cellElement);\r\n\r\n        //  Update the map of cells\r\n        cellMap.push({\r\n          cellElement: cellElement,\r\n          crossword: this,\r\n          cell: cell\r\n        });\r\n\r\n      }\r\n\r\n    }\r\n\r\n    parentElement.appendChild(container);\r\n  };\r\n\r\n  //  Selects a clue.\r\n  Crossword.prototype.selectClue = function selectClue(clue) {\r\n    this.currentClue = clue;\r\n    this._updateDOM();\r\n    this.currentClue.cells[0].cellElement.focus();\r\n    this._stateChange(\"clueSelected\");\r\n  };\r\n\r\n  //  Completely cleans up the crossword.\r\n  Crossword.prototype.destroyDOM = function destroyDOM() {\r\n    \r\n    //  Remove all cellmap entries.\r\n    for(var i=0; i<cellMap.length; i++) {\r\n      var entry = cellMap[i];\r\n      if(entry.crossword === this) {\r\n        cellMap.splice(i--, 1);\r\n      }\r\n    }\r\n\r\n    //  Destroy the DOM.\r\n    this.parentElement.removeChild(this.crosswordElement);\r\n\r\n    //  Clean up the object.\r\n    this.onStateChanged = null;\r\n\r\n  };\r\n\r\n  //  Sends a state change message.\r\n  Crossword.prototype._stateChange = function _stateChange(message, data) {\r\n\r\n    var eventHandler = this.onStateChanged;\r\n    if(!eventHandler) {\r\n      return;\r\n    }\r\n\r\n    //  Send the message.\r\n    eventHandler({\r\n      message: message,\r\n      data: data\r\n    });\r\n\r\n  };\r\n\r\n  //  Creates DOM for a cell.\r\n  Crossword.prototype._createCellDOM = function _createCellDOM(cell) {\r\n\r\n    var cellElement = document.createElement('div');\r\n    cellElement.className = \"cwcell\";\r\n    cell.cellElement = cellElement;\r\n\r\n    //  Add a class.\r\n    cellElement.className += cell.light ? \" light\" : \" dark\";\r\n\r\n    //  If the cell is dark, we are done.\r\n    if(!cell.light) {\r\n      return cellElement;\r\n    }\r\n\r\n    //  Light cells also need an input.\r\n    var inputElement = document.createElement('input');\r\n    inputElement.maxLength = 1;\r\n    cellElement.appendChild(inputElement);\r\n\r\n    //  We may need to add a clue label.\r\n    if(cell.clueLabel) {\r\n      var clueLabel = document.createElement('div');\r\n      clueLabel.className = \"cwcluelabel\";\r\n      clueLabel.innerHTML = cell.clueLabel;\r\n      cellElement.appendChild(clueLabel);\r\n    }\r\n\r\n    //  Listen for focus events.\r\n    inputElement.addEventListener(\"focus\", function(event) {\r\n\r\n      //  Get the cell data.\r\n      var cellElement = event.target.parentNode;\r\n      var cellData = getCellElementData(cellElement);\r\n      var crossword = cellData.crossword;\r\n      var across = cellData.cell.acrossClue;\r\n      var down = cellData.cell.downClue;\r\n\r\n      //  If we have clicked somewhere which is part of the current clue, we\r\n      //  will not need to change it (we won't toggle either).\r\n      if(crossword.currentClue && \r\n         (crossword.currentClue === across ||\r\n          crossword.currentClue === down)) {\r\n        return;\r\n      }\r\n\r\n      //  If we have an across clue XOR a down clue, pick the one we have.\r\n      if( (across && !down) || (!across && down) ) {\r\n        crossword.currentClue = across || down;\r\n      } else {\r\n        //  We've got across AND down. Prefer across, unless we've on the \r\n        //  first letter of a down clue only\r\n        crossword.currentClue = cellData.cell.downClueLetterIndex === 0 && cellData.cell.acrossClueLetterIndex !== 0 ? down : across;     \r\n      }\r\n\r\n      //  Update the DOM, inform of state change.\r\n      crossword._updateDOM();\r\n      crossword._stateChange(\"clueSelected\");\r\n      \r\n    });\r\n\r\n    //  Listen for keydown events.\r\n    cellElement.addEventListener(\"keydown\", function(event) {\r\n\r\n      if(event.keyCode === 8) { // backspace\r\n          \r\n        //  Blat the contents of the cell. No need to process the backspace.\r\n        event.preventDefault();\r\n        event.target.value = \"\";\r\n\r\n        //  Try and move to the previous cell of the clue.\r\n        var cellElement = event.target.parentNode;\r\n        var cellData = getCellElementData(cellElement);\r\n        var cell = cellData.cell;\r\n        var clue = cellData.crossword.currentClue;\r\n        var currentIndex = cell.acrossClue === clue ? cell.acrossClueLetterIndex : cell.downClueLetterIndex;\r\n        var previousIndex = currentIndex - 1;\r\n        if(previousIndex >= 0) {\r\n          clue.cells[previousIndex].cellElement.querySelector('input').focus();\r\n        }\r\n\r\n      } else if(event.keyCode === 9) { // tab\r\n\r\n        //  We don't want default behaviour.\r\n        event.preventDefault();\r\n\r\n        //  Get the cell element and cell data.\r\n        var cellElement = event.target.parentNode;\r\n        var cellData = getCellElementData(cellElement);\r\n        var clue = cellData.crossword.currentClue;\r\n        var model = cellData.crossword;\r\n\r\n        //  Get the next clue.\r\n        var searchClues = clue.across ? model.acrossClues : model.downClues;\r\n        for(var i=0; i<searchClues.length; i++) {\r\n          if(clue === searchClues[i]) {\r\n            var newClue = null;\r\n            if(event.shiftKey) {\r\n              if(i > 0) {\r\n                newClue = searchClues[i-1];\r\n              } else {\r\n                newClue = clue.across ? model.downClues[model.downClues.length-1] : model.acrossClues[model.acrossClues.length-1];\r\n              }\r\n            } else {\r\n              if(i < (searchClues.length - 1)) {\r\n                newClue = searchClues[i+1];\r\n              } else {\r\n                newClue = clue.across ? model.downClues[0] : model.acrossClues[0];\r\n              }\r\n            }\r\n            //  Select the new clue.\r\n            model.currentClue = newClue;\r\n            model._updateDOM();\r\n            newClue.cells[0].cellElement.querySelector('input').focus({internal: true});\r\n            break;\r\n          }\r\n        }\r\n\r\n      } else if (event.keyCode === 13) { // enter\r\n\r\n        //  We don't want default behaviour.\r\n        event.preventDefault();\r\n\r\n        //  Get the cell element and cell data.\r\n        var cellElement = event.target.parentNode;\r\n        var cellData = getCellElementData(cellElement);\r\n        var cell = cellData.cell;\r\n        var model = cellData.crossword;\r\n\r\n        //  If we are in a cell with an across clue AND down clue, swap the\r\n        //  selected one.\r\n        if(cell.acrossClue && cell.downClue) {\r\n          model.currentClue = cell.acrossClue === model.currentClue ? cell.downClue : cell.acrossClue;\r\n          model._updateDOM();\r\n        }\r\n\r\n      }\r\n\r\n    });\r\n\r\n    //  Listen for keypress events.\r\n    cellElement.addEventListener(\"keypress\", function(event) {\r\n\r\n      //  We've just pressed a key that generates a char. In all\r\n      //  cases, we're going to overwrite by blatting the current \r\n      //  content. If the key is space, we suppress so we don't get\r\n      //  a space, then we always move to the next cell in the clue.\r\n      \r\n      //  No spaces in empty cells.\r\n      if(event.keyCode === 32) {\r\n        event.preventDefault();\r\n      }\r\n\r\n      //  Blat current content.\r\n      event.target.value = \"\";\r\n\r\n      //  Move to the next cell in the clue.\r\n      var cellElement = event.target.parentNode;\r\n      var cellData = getCellElementData(cellElement);\r\n      var cell = cellData.cell;\r\n      var clue = cellData.crossword.currentClue;\r\n      var currentIndex = cell.acrossClue === clue ? cell.acrossClueLetterIndex : cell.downClueLetterIndex;\r\n      var nextIndex = currentIndex + 1;\r\n      if(nextIndex < clue.cells.length) {\r\n        clue.cells[nextIndex].cellElement.querySelector('input').focus();\r\n      }\r\n\r\n    });\r\n\r\n    //  Listen for keyup events.\r\n    cellElement.addEventListener(\"keyup\", function(event) {\r\n      switch (event.keyCode) {\r\n        case 37: // left\r\n        \r\n          var cellElement = event.target.parentNode;\r\n          var cellData = getCellElementData(cellElement);\r\n          var cell = cellData.cell;\r\n          var x = cell.x, y = cell.y;\r\n\r\n          //  If we can go left, go left.\r\n          if(cell.x > 0 && cellData.crossword.cells[x-1][y].light === true) {\r\n            //  TODO: optimise with children[0]?\r\n            cellData.crossword.cells[x-1][y].cellElement.querySelector('input').focus();\r\n          }\r\n          break;\r\n        case 38: // up\r\n          var cellElement = event.target.parentNode;\r\n          var cellData = getCellElementData(cellElement);\r\n          var cell = cellData.cell;\r\n          var x = cell.x, y = cell.y;\r\n\r\n          //  If we can go up, go up.\r\n          if(cell.y > 0 && cellData.crossword.cells[x][y-1].light === true) {\r\n            //  TODO: optimise with children[0]?\r\n            cellData.crossword.cells[x][y-1].cellElement.querySelector('input').focus();\r\n          }\r\n          break;\r\n        case 39: // right\r\n          var cellElement = event.target.parentNode;\r\n          var cellData = getCellElementData(cellElement);\r\n          var cell = cellData.cell, width = cellData.crossword.width;\r\n          var x = cell.x, y = cell.y;\r\n\r\n          //  If we can go right, go right.\r\n          if(cell.x + 1 < width && cellData.crossword.cells[x+1][y].light === true) {\r\n            //  TODO: optimise with children[0]?\r\n            cellData.crossword.cells[x+1][y].cellElement.querySelector('input').focus();\r\n          }\r\n          break;\r\n        case 40: // down\r\n          var cellElement = event.target.parentNode;\r\n          var cellData = getCellElementData(cellElement);\r\n          var cell = cellData.cell, height = cellData.crossword.height;\r\n          var x = cell.x, y = cell.y;\r\n\r\n          //  If we can go down, go down.\r\n          if(cell.y + 1 < height && cellData.crossword.cells[x][y+1].light === true) {\r\n            //  TODO: optimise with children[0]?\r\n            cellData.crossword.cells[x][y+1].cellElement.querySelector('input').focus();\r\n          }\r\n          break;\r\n        case 9: // tab\r\n          //  todo\r\n          break;\r\n\r\n        default: // anything else...\r\n          //  todo\r\n          break;\r\n      }\r\n    });\r\n\r\n    return cellElement;\r\n  };\r\n\r\n  //  Updates the DOM based on the model, ensuring that the CSS\r\n  //  is correct for the state (i.e. the selected clue).\r\n  Crossword.prototype._updateDOM = function _updateDOM(crosswordModel) {\r\n\r\n    //  TODO: pick a name - active, current or selected.\r\n    var activeClue = this.currentClue;\r\n\r\n    //  Deactivate all cells, except those which match the clue.\r\n    for(var x = 0; x < this.cells.length; x++) {\r\n      for(var y = 0; y < this.cells[x].length; y++) {\r\n        var cell = this.cells[x][y];\r\n        if(cell.light === true) { \r\n          if((cell.acrossClue === activeClue) || (cell.downClue === activeClue)) {\r\n            addClass(cell.cellElement.querySelector('input'), \"active\");\r\n          } else {\r\n            removeClass(cell.cellElement.querySelector('input'), \"active\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  //  Builds a crossword from options.\r\n  function buildCrossword(options) {\r\n\r\n    //  Validate the options.\r\n    if(options === null || options === undefined) {\r\n      throw new Error(\"An options parameter must be passed to 'crossword'.\");\r\n    }\r\n    if(options.element === null || options.element === undefined) {\r\n      throw new Error(\"The crossword must be initialised with a valid DOM element.\");\r\n    }\r\n\r\n    //  Create the crossword object. Throws an exception if there are any issues.\r\n    return new Crossword(options.element, options.crosswordDefinition);\r\n  }\r\n\r\n  //  Define our public API.\r\n  return {\r\n    Crossword: Crossword,\r\n    CrosswordDOM: CrosswordDOM\r\n  };\r\n\r\n})(window, document);"],"sourceRoot":"/source/"}